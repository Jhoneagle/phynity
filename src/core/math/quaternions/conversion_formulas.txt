================================================================================
NUMERICALLY STABLE QUATERNION CONVERSION FORMULAS
================================================================================
Document Purpose: Mathematical reference for implementing stable quaternion
conversions. All formulas are designed to handle edge cases and avoid numerical
instabilities including gimbal lock, division by zero, and floating-point
precision issues.

Conventions:
- Quaternion: q = (w, x, y, z) = (w, v) where v = (x, y, z)
- Unit quaternion represents rotation: ||q|| = 1
- Euler angles: (roll, pitch, yaw) = (φ, θ, ψ) in radians
- Rotation order: ZYX (yaw → pitch → roll) intrinsic rotations
- Matrix storage: Row-major m[row][col]

================================================================================
1. QUATERNION TO ROTATION MATRIX (3×3)
================================================================================

FORMULA (for unit quaternion q = (w, x, y, z)):

Given: q normalized such that w² + x² + y² + z² = 1

Rotation Matrix R:
┌                                                          ┐
│ 1-2(y²+z²)    2(xy-wz)      2(xz+wy)    │
│ 2(xy+wz)      1-2(x²+z²)    2(yz-wx)    │
│ 2(xz-wy)      2(yz+wx)      1-2(x²+y²)  │
└                                                          ┘

Optimized form (fewer multiplications):
Let: xx = x*x,  yy = y*y,  zz = z*z
     xy = x*y,  xz = x*z,  yz = y*z
     wx = w*x,  wy = w*y,  wz = w*z

R = ┌                                    ┐
    │ 1-2(yy+zz)   2(xy-wz)    2(xz+wy) │
    │ 2(xy+wz)     1-2(xx+zz)  2(yz-wx) │
    │ 2(xz-wy)     2(yz+wx)    1-2(xx+yy)│
    └                                    ┘

IMPLEMENTATION NOTES:
1. Always normalize quaternion before conversion
2. Use the optimized form to reduce floating-point operations
3. No special case handling needed - formula is stable for all valid quaternions
4. For non-unit quaternions, divide by ||q||² or normalize first

NUMERICAL STABILITY:
- No division operations required
- All operations are additions and multiplications
- Robust for all orientations (no singularities)
- Machine epsilon: differences < 1e-6 can be ignored

================================================================================
2. ROTATION MATRIX TO QUATERNION
================================================================================

PROBLEM: Direct formulas involve square roots and can be unstable when
         denominators approach zero. Different formulas are stable in
         different regions.

SOLUTION: Shepperd's method - choose the largest diagonal element to avoid
          division by small numbers.

Let R = [r00  r01  r02]
        [r10  r11  r12]
        [r20  r21  r22]

Define trace: tr = r00 + r11 + r22

ALGORITHM (4 cases based on which component is largest):

CASE 1: tr > 0 (most common case, use w as base)
    w = 0.5 * sqrt(1 + tr)
    s = 0.25 / w
    x = (r21 - r12) * s
    y = (r02 - r20) * s
    z = (r10 - r01) * s

CASE 2: (r00 > r11) AND (r00 > r22) (use x as base)
    x = 0.5 * sqrt(1 + r00 - r11 - r22)
    s = 0.25 / x
    w = (r21 - r12) * s
    y = (r01 + r10) * s
    z = (r02 + r20) * s

CASE 3: r11 > r22 (use y as base)
    y = 0.5 * sqrt(1 + r11 - r00 - r22)
    s = 0.25 / y
    w = (r02 - r20) * s
    x = (r01 + r10) * s
    z = (r12 + r21) * s

CASE 4: otherwise (use z as base)
    z = 0.5 * sqrt(1 + r22 - r00 - r11)
    s = 0.25 / z
    w = (r10 - r01) * s
    x = (r02 + r20) * s
    y = (r12 + r21) * s

IMPLEMENTATION NOTES:
1. Always choose the case with largest component to avoid division by small numbers
2. Input matrix should be orthonormal (validate with det(R) ≈ 1, R*R^T ≈ I)
3. Result should be normalized (though it should be unit if R is valid)

NUMERICAL STABILITY:
- Selecting largest component ensures denominator is never close to zero
- Square root argument is always non-negative for valid rotation matrices
- Threshold for trace comparison: use simple > comparison (no epsilon needed)

VALIDATION:
After conversion, verify: w² + x² + y² + z² ≈ 1 (within 1e-6)

================================================================================
3. QUATERNION TO EULER ANGLES (ZYX ORDER)
================================================================================

PROBLEM: Gimbal lock occurs when pitch ≈ ±90°, causing roll and yaw to
         become dependent. Standard formulas become numerically unstable.

Given: Unit quaternion q = (w, x, y, z)
Output: Euler angles (roll, pitch, yaw) = (φ, θ, ψ)

Rotation order: ZYX (intrinsic) = XYZ (extrinsic)
This means: R = Rz(ψ) * Ry(θ) * Rx(φ)

FORMULA:

First compute the singularity test value:
    singularity_test = 2 * (w*y - z*x)

CASE 1: Normal case (|singularity_test| < 0.9999)
    roll  (φ) = atan2(2(w*x + y*z), 1 - 2(x² + y²))
    pitch (θ) = asin(singularity_test)
    yaw   (ψ) = atan2(2(w*z + x*y), 1 - 2(y² + z²))

CASE 2: Gimbal lock at pitch = +90° (singularity_test ≥ 0.9999)
    roll  (φ) = 0.0  (arbitrary choice, by convention)
    pitch (θ) = π/2  (90 degrees)
    yaw   (ψ) = atan2(-2(x*y - w*z), 1 - 2(y² + z²))  (yaw captures combined rotation)

CASE 3: Gimbal lock at pitch = -90° (singularity_test ≤ -0.9999)
    roll  (φ) = 0.0  (arbitrary choice, by convention)
    pitch (θ) = -π/2 (-90 degrees)
    yaw   (ψ) = atan2(-2(x*y - w*z), 1 - 2(y² + z²))  (yaw captures combined rotation)

IMPLEMENTATION NOTES:
1. Normalize quaternion before conversion
2. Use 0.9999 threshold to avoid numerical instability near ±90° pitch
3. In gimbal lock, set roll to zero by convention (yaw absorbs combined rotation)
4. Output angles are in range: roll ∈ [-π, π], pitch ∈ [-π/2, π/2], yaw ∈ [-π, π]

NUMERICAL STABILITY:
- atan2 is always stable (handles all quadrants, no division by zero)
- asin argument is clamped implicitly by singularity test
- Gimbal lock formulas avoid undefined atan2(0,0) situations
- Threshold 0.9999 provides safety margin for floating-point errors

ALTERNATIVE ORDERS:
For different Euler conventions (XYZ, YXZ, etc.), the formulas change but
the principle remains: detect gimbal lock and handle it explicitly

================================================================================
4. EULER ANGLES TO QUATERNION (ZYX ORDER)
================================================================================

Given: Euler angles (roll, pitch, yaw) = (φ, θ, ψ) in radians
Output: Unit quaternion q = (w, x, y, z)

Rotation order: ZYX (same as above)

FORMULA:

Compute half-angles:
    φ/2 = roll / 2
    θ/2 = pitch / 2
    ψ/2 = yaw / 2

Compute sines and cosines:
    cr = cos(φ/2),  sr = sin(φ/2)
    cp = cos(θ/2),  sp = sin(θ/2)
    cy = cos(ψ/2),  sy = sin(ψ/2)

Quaternion components:
    w = cy*cp*cr + sy*sp*sr
    x = cy*cp*sr - sy*sp*cr
    y = cy*sp*cr + sy*cp*sr
    z = sy*cp*cr - cy*sp*sr

IMPLEMENTATION NOTES:
1. Input angles should be in radians
2. No normalization needed - result is automatically a unit quaternion
3. Works for all angle values (including pitch = ±90°)
4. Can handle angles outside standard ranges (e.g., yaw > 2π)

NUMERICAL STABILITY:
- All operations are multiplications and additions of trigonometric values
- No divisions or square roots
- Stable for all input angles including extreme values
- Result magnitude should be 1.0 ± 1e-6

GIMBAL LOCK HANDLING:
This conversion does NOT suffer from gimbal lock - it produces a valid
quaternion for any input Euler angles, including pitch = ±90°.
The gimbal lock issue only appears in the reverse direction
(quaternion → Euler).

================================================================================
5. QUATERNION TO AXIS-ANGLE
================================================================================

Given: Unit quaternion q = (w, x, y, z)
Output: axis (unit vector), angle (radians)

FORMULA:

CASE 1: Regular rotation (|w| < 1.0)
    angle = 2 * acos(w)
    
    s = sqrt(1 - w²)  [this is sin(angle/2)]
    
    If s > 1e-6:
        axis.x = x / s
        axis.y = y / s
        axis.z = z / s
    Else:
        axis = (1, 0, 0)  [arbitrary, angle ≈ 0 or π]

CASE 2: Identity quaternion (w ≈ 1, very small rotation)
    angle = 0
    axis = (1, 0, 0)  [arbitrary - no rotation occurs]

CASE 3: 180° rotation (w ≈ 0)
    angle = π
    
    Find largest component of (x, y, z) and normalize:
    mag = sqrt(x² + y² + z²)
    axis = (x/mag, y/mag, z/mag)

IMPLEMENTATION NOTES:
1. Always check |w| before computing acos to ensure valid input [-1, 1]
2. Clamp w to [-1, 1] if numerical errors push it slightly outside
3. For near-identity quaternions (w ≈ 1), angle ≈ 0 is safe
4. Use threshold 1e-6 for s to avoid division by near-zero

NUMERICAL STABILITY:
- acos(w) is stable for w ∈ [-1, 1]
- Division by s is protected by threshold check
- Special cases handle angle ≈ 0 and angle ≈ π
- Axis should always be unit vector (verify: ||axis|| ≈ 1)

ANGLE RANGE:
Output angle ∈ [0, π] (always positive, direction is in axis)

================================================================================
6. AXIS-ANGLE TO QUATERNION
================================================================================

Given: axis (unit vector), angle θ (radians)
Output: Unit quaternion q = (w, x, y, z)

FORMULA:

half_angle = θ / 2
s = sin(half_angle)
c = cos(half_angle)

w = c
x = axis.x * s
y = axis.y * s
z = axis.z * s

IMPLEMENTATION NOTES:
1. Input axis MUST be normalized (||axis|| = 1)
2. Angle can be any value (not limited to [0, 2π])
3. No special cases needed - formula works for all angles
4. Result is automatically unit quaternion

NUMERICAL STABILITY:
- All operations are stable trigonometric evaluations
- No divisions or square roots needed
- Works correctly for angle = 0 (gives identity)
- Works correctly for angle = 2π (gives identity)

ALREADY IMPLEMENTED:
This conversion is already implemented in Quat constructor:
    Quat(const Vec3& axis, float angle)

================================================================================
7. QUATERNION SLERP (Spherical Linear Interpolation)
================================================================================

Given: Two unit quaternions q₀, q₁ and parameter t ∈ [0, 1]
Output: Interpolated quaternion q_t

PROBLEM: Linear interpolation (LERP) doesn't preserve constant angular velocity.
         Naive SLERP formula can be numerically unstable when quaternions are
         very close (dot product ≈ 1).

ALGORITHM:

1. Compute dot product:
    cos_theta = dot(q₀, q₁) = w₀*w₁ + x₀*x₁ + y₀*y₁ + z₀*z₁

2. Handle quaternion double-cover (choose shorter path):
    If cos_theta < 0:
        q₁ = -q₁
        cos_theta = -cos_theta

3. Choose interpolation method based on angle:

   CASE A: Quaternions are very close (cos_theta > 0.9995)
      Use NLERP (normalized linear interpolation):
          q_t = normalize((1-t)*q₀ + t*q₁)
      
   CASE B: Normal case (cos_theta ≤ 0.9995)
      Use SLERP:
          theta = acos(cos_theta)
          sin_theta = sin(theta)
          
          scale₀ = sin((1-t) * theta) / sin_theta
          scale₁ = sin(t * theta) / sin_theta
          
          q_t = scale₀ * q₀ + scale₁ * q₁

IMPLEMENTATION NOTES:
1. Always normalize input quaternions before SLERP
2. Threshold 0.9995 corresponds to angle ≈ 2.5°
3. NLERP is cheaper and nearly identical for small angles
4. Result should be normalized (though it should be unit already)

NUMERICAL STABILITY:
- Dot product check avoids long path around hypersphere
- NLERP fallback avoids division by sin(small_angle) ≈ 0
- Threshold 0.9995 provides safety margin
- All sine/cosine values are stable for theta ∈ [0, π]

PERFORMANCE:
- NLERP: ~15 flops (much faster than SLERP)
- SLERP: ~50+ flops (includes trig functions)
- Use NLERP for chains of many interpolations (accumulates slight error)

================================================================================
8. TESTING RECOMMENDATIONS
================================================================================

TOLERANCE GUIDELINES:
- Standard tolerance: 1e-6 (good for single-precision float)
- Accumulated operations: 1e-5 (conversions + rotations)
- Gimbal lock regions: 1e-4 (near pitch = ±90°)

CRITICAL TEST CASES:

Identity:
    q = (1, 0, 0, 0)
    → Euler: (0, 0, 0)
    → Matrix: I₃

90° rotations around each axis:
    X: q = (√2/2, √2/2, 0, 0)     → Euler: (90°, 0, 0)
    Y: q = (√2/2, 0, √2/2, 0)     → Euler: (0, 90°, 0)
    Z: q = (√2/2, 0, 0, √2/2)     → Euler: (0, 0, 90°)

180° rotations:
    X: q = (0, 1, 0, 0)
    Y: q = (0, 0, 1, 0)
    Z: q = (0, 0, 0, 1)

Gimbal lock cases:
    Pitch = +90°: (0°, 90°, any°)  → test singularity_test ≈ 0.5
    Pitch = -90°: (0°, -90°, any°) → test singularity_test ≈ -0.5

Arbitrary rotations:
    Combined XYZ: (30°, 45°, 60°)
    Large angles: (179°, 89°, 271°)

Round-trip tests:
    Quat → Matrix → Quat:  should recover original (within 1e-5)
    Quat → Euler → Quat:   should recover original (except gimbal lock)
    Matrix → Quat → Matrix: should recover original (within 1e-5)

Numerical stress tests:
    Very small angles: (0.001°, 0°, 0°)
    Near gimbal lock: (any, 89.9°, any), (any, -89.9°, any)
    Denormalized quaternions: normalize then convert

Edge cases for SLERP:
    t = 0:   should return q₀
    t = 1:   should return q₁
    t = 0.5: should be halfway rotation
    Opposite quaternions: dot(q₀, q₁) < 0

================================================================================
9. COMMON PITFALLS AND SOLUTIONS
================================================================================

PITFALL 1: Not normalizing quaternions before conversions
SOLUTION: Always normalize first, or assert ||q|| ≈ 1 in debug builds

PITFALL 2: Ignoring quaternion double-cover (q and -q represent same rotation)
SOLUTION: In comparisons/interpolation, check dot product sign

PITFALL 3: Using wrong Euler angle convention
SOLUTION: Document convention clearly (we use ZYX intrinsic)

PITFALL 4: Gimbal lock in Euler angles causing test failures
SOLUTION: Use larger tolerance (1e-4) near pitch = ±90°, or avoid testing
          exact round-trips through Euler at gimbal lock

PITFALL 5: Comparing floating-point values with exact equality
SOLUTION: Use Catch2 WithinAbs() or WithinRel() matchers

PITFALL 6: Matrix not orthonormal before conversion to quaternion
SOLUTION: Validate matrix properties or orthonormalize first

PITFALL 7: Accumulating numerical error in sequences of operations
SOLUTION: Re-normalize periodically, use quaternions instead of matrices
          for rotation accumulation

PITFALL 8: Using degrees instead of radians
SOLUTION: All implementations use radians; convert at API boundary only

================================================================================
10. IMPLEMENTATION CHECKLIST
================================================================================

Before implementing each conversion:
☐ Read the formula carefully and understand each case
☐ Identify all edge cases and singularities
☐ Implement with explicit case handling (if-else)
☐ Add normalization where needed
☐ Use meaningful variable names (not just a, b, c)
☐ Add comments explaining the mathematical reasoning
☐ Include reference to this document

After implementing:
☐ Write comprehensive unit tests covering all cases
☐ Test with identity and basis rotations
☐ Test gimbal lock cases (for Euler conversions)
☐ Test round-trip conversions
☐ Verify tolerances are appropriate (1e-6 typical, 1e-4 near singularities)
☐ Check performance (especially for SLERP)
☐ Document any deviations from these formulas

================================================================================
REFERENCES
================================================================================

1. Shepperd, S. W. (1978). "Quaternion from rotation matrix."
   Journal of Guidance and Control, Vol. 1, No. 3, pp. 223-224.
   [Source for stable matrix-to-quaternion conversion]

2. Diebel, J. (2006). "Representing Attitude: Euler Angles, Unit Quaternions,
   and Rotation Vectors." Stanford University.
   [Comprehensive overview of rotation representations]

3. Eberly, D. (2010). "Conversion Between Quaternions and Euler Angles."
   Geometric Tools.
   [Details on gimbal lock handling]

4. Shoemake, K. (1985). "Animating rotation with quaternion curves."
   ACM SIGGRAPH Computer Graphics, 19(3), pp. 245-254.
   [Original SLERP paper]

5. Hanson, A. J. (2006). "Visualizing Quaternions."
   Morgan Kaufmann / Elsevier.
   [Geometric intuition and visualization techniques]

================================================================================
END OF DOCUMENT
================================================================================
Version: 1.0
Date: 2026-01-02
Author: Documentation for Phynity physics engine
Target: Numerically stable quaternion conversion implementations
================================================================================
